<!-- vscode-markdown-toc -->
	* 1. [<font color = pink>Hello world</font>](#fontcolorpinkHelloworldfont)
	* 2. [<font color = pink>注释</font>](#fontcolorpinkfont)
	* 3. [<font color = pink>变量</font>](#fontcolorpinkfont-1)
	* 4. [<font color = pink>常量</font>](#fontcolorpinkfont-1)
	* 5. [<font color = pink>关键字：C++中预先保留的单词</font>](#fontcolorpinkCfont)
	* 6. [<font color = pink>标识符命名规则</font>](#fontcolorpinkfont-1)
	* 7. [<font color = pink>数据类型</font>](#fontcolorpinkfont-1)
	* 8. [<font color = pink>关键字 sizeof</font>](#fontcolorpinksizeoffont)
	* 9. [<font color = pink>整型</font>](#fontcolorpinkfont-1)
	* 10. [<font color = pink>浮点型（实型）</font>](#fontcolorpinkfont-1)
	* 11. [<font color = pink>字符型</font>](#fontcolorpinkfont-1)
	* 12. [<font color = pink>转义字符（c语言用的比较多）</font>](#fontcolorpinkcfont)
	* 13. [<font color = pink>字符串型</font>](#fontcolorpinkfont-1)
	* 14. [<font color = pink>布尔类型 bool</font>](#fontcolorpinkboolfont)
	* 15. [<font color = pink>数据的输入</font>](#fontcolorpinkfont-1)
	* 16. [<font color = pink>运算符</font>](#fontcolorpinkfont-1)
	* 17. [<font color = pink>程序流程结构</font>](#fontcolorpinkfont-1)
	* 18. [<font color = pink>选择</font>](#fontcolorpinkfont-1)
	* 19. [<font color = pink>循环</font>](#fontcolorpinkfont-1)
	* 20. [<font color = pink>一维数组定义</font>](#fontcolorpinkfont-1)
	* 21. [<font color = pink>一维数组的名称</font>](#fontcolorpinkfont-1)
	* 22. [<font color = pink>冒泡排序</font>](#fontcolorpinkfont-1)
	* 23. [<font color = pink>二维数组定义</font>](#fontcolorpinkfont-1)
	* 24. [<font color = pink>二维数组的名称</font>](#fontcolorpinkfont-1)
	* 25. [<font color = pink>字符串数组</font>](#fontcolorpinkfont-1)
	* 26. [<font color = pink>函数</font>](#fontcolorpinkfont-1)
	* 27. [<font color = pink>函数的定义</font>](#fontcolorpinkfont-1)
	* 28. [<font color = pink>函数的调用</font>](#fontcolorpinkfont-1)
	* 29. [<font color = pink>值传递</font>](#fontcolorpinkfont-1)
	* 30. [<font color = pink>函数的常见样式</font>](#fontcolorpinkfont-1)
	* 31. [<font color = pink>函数的声明</font>](#fontcolorpinkfont-1)
	* 32. [<font color = pink>函数的分文件编写</font>](#fontcolorpinkfont-1)
	* 33. [<font color = pink>指针</font>](#fontcolorpinkfont-1)
	* 34. [<font color = pink>指针所占用的内存空间</font>](#fontcolorpinkfont-1)
	* 35. [<font color = pink>空指针</font>](#fontcolorpinkfont-1)
	* 36. [<font color = pink>野指针</font>](#fontcolorpinkfont-1)
	* 37. [<font color = pink>const修饰指针</font>](#fontcolorpinkconstfont)
	* 38. [<font color = pink>指针和数组</font>](#fontcolorpinkfont-1)
	* 39. [<font color = pink>指针和函数</font>](#fontcolorpinkfont-1)
	* 40. [<font color = pink>结构</font>](#fontcolorpinkfont-1)
	* 41. [<font color = pink>结构体数组</font>](#fontcolorpinkfont-1)
	* 42. [<font color = pink>结构体指针</font>](#fontcolorpinkfont-1)
	* 43. [<font color = pink>嵌套结构体</font>](#fontcolorpinkfont-1)
	* 44. [<font color = pink>结构体作函数参数</font>](#fontcolorpinkfont-1)
	* 45. [<font color = pink>结构体与const</font>](#fontcolorpinkconstfont-1)
	* 46. [<font color = pink>指针拷贝结构体</font>](#fontcolorpinkfont-1)
	* 47. [<font color = pink>内存四区</font>](#fontcolorpinkfont-1)
	* 48. [<font color = pink>动态内存申请与释放</font>](#fontcolorpinkfont-1)
	* 49. [<font color = pink>引用</font>](#fontcolorpinkfont-1)
	* 50. [<font color = pink>值传递	地址传递	引用传递</font>](#fontcolorpinkfont-1)
	* 51. [<font color = pink>函数提高</font>](#fontcolorpinkfont-1)
	* 52. [<font color = pink>类和对象（封装继承多态）</font>](#fontcolorpinkfont-1)
	* 53. [<font color = pink>封装</font>](#fontcolorpinkfont-1)
	* 54. [<font color = pink>访问权限（public、protected、private）</font>](#fontcolorpinkpublicprotectedprivatefont)
	* 55. [<font color = pink>struct 和 class</font>](#fontcolorpinkstructclassfont)
	* 56. [<font color = pink>私有化成员属性（通过预留的公有接口访问）</font>](#fontcolorpinkfont-1)
	* 57. [<font color = pink>对象的初始化和清理（构造与析构）</font>](#fontcolorpinkfont-1)
	* 58. [<font color = pink>构造函数的分类及调用</font>](#fontcolorpinkfont-1)
	* 59. [<font color = pink>拷贝构造调用时机（什么时候用到拷贝构造）</font>](#fontcolorpinkfont-1)
	* 60. [<font color = pink>构造函数的调用规则</font>](#fontcolorpinkfont-1)
	* 61. [<font color = pink>浅拷贝与深拷贝</font>](#fontcolorpinkfont-1)
	* 62. [<font color = pink>对象初始化：初始化列表</font>](#fontcolorpinkfont-1)
	* 63. [<font color = pink>类对象作为类成员</font>](#fontcolorpinkfont-1)
	* 64. [<font color = pink>静态成员</font>](#fontcolorpinkfont-1)
	* 65. [<font color = pink>C++对象模型（成员变量和成员函数分开存储）</font>](#fontcolorpinkCfont-1)
	* 66. [<font color = pink>this 指针</font>](#fontcolorpinkthisfont)
	* 67. [<font color = pink>空指针访问成员函数</font>](#fontcolorpinkfont-1)
	* 68. [<font color = pink>const 修饰成员函数</font>](#fontcolorpinkconstfont-1)
	* 69. [<font color = pink>友元</font>](#fontcolorpinkfont-1)
	* 70. [<font color = pink>运算符重载</font>](#fontcolorpinkfont-1)
	* 71. [<font color = pink>继承</font>](#fontcolorpinkfont-1)
	* 72. [<font color = pink>开发人员命令提示查看对象模型</font>](#fontcolorpinkfont-1)
	* 73. [<font color = pink>多继承</font>](#fontcolorpinkfont-1)
	* 74. [<font color = pink>virtual 虚继承</font>](#fontcolorpinkvirtualfont)
	* 75. [<font color = pink>文件流</font>](#fontcolorpinkfont-1)
	* 76. [<font color = pink>模板</font>](#fontcolorpinkfont-1)
	* 77. [<font color = pink>STL - standard template library（标准模板库）</font>](#fontcolorpinkSTL-standardtemplatelibraryfont)

<!-- vscode-markdown-toc-config
	numbering=true
	autoSave=true
	/vscode-markdown-toc-config -->
<!-- /vscode-markdown-toc -->
# <font color = skyblue>CPP基础编程（C语言）</font>
###  1. <a name='fontcolorpinkHelloworldfont'></a><font color = pink>Hello world</font>
main是一个程序的入口，每个程序都必须有一个。
```cpp
int main(){return 0;}
int main(int argc, char *argv[]){return 0;}
```
下面这个是标准main函数，可以由操作系统传入一些参数。
```cpp
system("pause");
```
###  2. <a name='fontcolorpinkfont'></a><font color = pink>注释</font>
```cpp
// 单行注释	
/*多行注释*/
```
###  3. <a name='fontcolorpinkfont-1'></a><font color = pink>变量</font>
变量存在的意义：方便管理内存空间。
给一段内存空间取名，方便管理这段空间。

变量创建的语法：
```cpp
数据类型 变量名 = 变量初始值;
int a = 10;
```
###  4. <a name='fontcolorpinkfont-1'></a><font color = pink>常量</font>
宏常量，语法：
```cpp
#define 常量名 常量值
```
const修饰的变量：语法：
```cpp
const 数据类型 常变量名 = 常量值;
```
###  5. <a name='fontcolorpinkCfont'></a><font color = pink>关键字：C++中预先保留的单词</font>
例如，整型int。不要用关键字给变量或者常量取名称。
###  6. <a name='fontcolorpinkfont-1'></a><font color = pink>标识符命名规则</font>
1、标识符不可以是关键字
2、只能包含字母数字下划线
3、第一个字符必须是字母或者下划线
4、标识符中的字母区分大小写

给变量起名的时候，最好能够做到见名知意。
###  7. <a name='fontcolorpinkfont-1'></a><font color = pink>数据类型</font>
C++ 规定在创建一个变量或者常量时。必须要指出相应的数据类型，否则无法给变量分配内存。
```cpp
short 短整型 2字节 16位 (-2^15~2^15-1)
int 整型 4字节
long 长整型 windows 4字节 Linux 4字节或8字节
long long 长长整型 8字节
```
数据类型存在的意义：给变量分配合适的空间。
###  8. <a name='fontcolorpinksizeoffont'></a><font color = pink>关键字 sizeof</font>
利用 sizeof 可以统计数据类型所占的大小，语法：
```cpp
sizeof(数据类型/变量);
sizeof(int);
```
###  9. <a name='fontcolorpinkfont-1'></a><font color = pink>整型</font>
整数的意思。
###  10. <a name='fontcolorpinkfont-1'></a><font color = pink>浮点型（实型）</font>
```cpp
单精度 float 4字节 7位有效数字
双精度 double 8字节 15~16位有效数字
```
科学计数法
```cpp
float f2 = 3e2;     // 300		
float f2 = 3e-2;    // 0.03
```
cpp默认小数是双精度，3.14f这是单精度小数。
控制台默认显示6位有效数字。
###  11. <a name='fontcolorpinkfont-1'></a><font color = pink>字符型</font>
语法：
```cpp
char ch = 'a';
```
注意用单引号，不可以是双引号，单引号只能有一个字符，不可以是字符串。c和cpp中字符型只占1字节。
字符型变量内部存储的对应的ASCII码，用强制转换查看ASCII码：
```cpp
cout << (int)ch << endl;    // a - 97 A - 65
```
ASCII码：0-31控制字符，其余是显示字符。
###  12. <a name='fontcolorpinkcfont'></a><font color = pink>转义字符（c语言用的比较多）</font>
作用：用于表示一些不能显示出来的ASCII字符。
```cpp
换行符 \n
反斜杠 \\
水平制表符号 \t
```
###  13. <a name='fontcolorpinkfont-1'></a><font color = pink>字符串型</font>
c语言风格字符串：
```cpp
char 变量名[] = "字符串值";     // []的作用是数组化，最后一位系统自己加\0
```
c++风格字符串：字符串变量 
```cpp
#include <string>
string 变量名 = "字符串值";	    // 注意包含一个头文件 #include <string>		
```
###  14. <a name='fontcolorpinkboolfont'></a><font color = pink>布尔类型 bool</font>
bool类型：占用1字节，非零的值都代表真，0代表假。
```cpp
bool flag = true;
```
###  15. <a name='fontcolorpinkfont-1'></a><font color = pink>数据的输入</font>
```cpp
cin >> 变量
int a = 0;
cin >> a; // >> 右运算符
```
###  16. <a name='fontcolorpinkfont-1'></a><font color = pink>运算符</font>
1、算数运算符
```cpp
除法：int n1 = 10; int n2 = 3; 则n1/n2 = 3，整数除法小数位会舍弃。
取模（取余）：10%3 = 1; 模3运算，只有整型可以取模运算，两个小数不能取模运算。

前置递增运算符 ++a	//先+1，再表达式运算
int a = 10;
int b = ++a * 10;		答案 110

后置递增运算符 a++	//先表达式运算，再让变量+1
int a = 10;
int b = a++ * 10;		答案 100
```
2、赋值运算符
```cpp
= 赋值
+= 加等于 a += 2; 等价于 a = a+2;
-= 减等于
*= 乘等于
/= 除等于
%= 模等于
```
3、比较运算符
```cpp
== 等于
!= 不等于
<
>
<=
>=
cout<< (a==b) <<endl;   // ()的作用是提高优先级
```
4、逻辑运算符
```cpp
!	非
&&	与	// 同真为真，其余为假
||	或
```
###  17. <a name='fontcolorpinkfont-1'></a><font color = pink>程序流程结构</font> 
1、顺序 2、选择 3、循环
###  18. <a name='fontcolorpinkfont-1'></a><font color = pink>选择</font>
单行 if 语句
```cpp
if(条件){条件满足执行的语句}
if条件语句后面加分号，则条件白写。
```
多行 if 语句
```cpp
if(条件){满足执行语句}else{条件不满足执行语句}
if(){}elseif(){}elseif(){}else{}
```
嵌套 if 语句

>练习 三只小猪称体重

三目运算符
```cpp
(条件1)?(条件2):(条件3);        // 1为真则执行条件2，1为假执行条件3
c = (a > b ? a:  b);           // 优点，比if结构简洁清晰
```
switch-case语句：switch的缺点，只能判断整型或者字符型，不能判断区间。
```cpp
switch(value)
{
	case = 结果1: 语句; break;  // break 是退出当前分支，不再执行
	default: 执行语句; break;
}
```
###  19. <a name='fontcolorpinkfont-1'></a><font color = pink>循环</font> 
while循环
>猜数字程序设计
```cpp
srand((unsigned int)time(NULL));    // srand 随机数种子 #include <ctime>
int num = rand() % 100;
```
do...while 语句

>练习：水仙花数，例如 1^3+5^3+3^3 = 153 每一位上的数字的立方之和等于本身，利用 do-while 语句，求出所有水仙花数。

for循环
```cpp 
for(起始表达式;条件表达式;末尾循环体){}
```
嵌套循环：循环计数变量冲突时候，采用就近原则。
>案例：乘法口诀表

跳转语句
```cpp
break 直接跳出循环 或 跳出 switch-case 语句
continue 跳出本次循环的后部分语句 执行下次循环
goto 标记
```
###  20. <a name='fontcolorpinkfont-1'></a><font color = pink>一维数组定义</font>
```cpp
int arr[len];
int arr[len] = {val1,val2,val3};
int arr[] = {val1,val2,val3};
```
特点：
放在一块连续的内存空间中，各个数据都是相同的数据类型。
数组从0开始索引，下标从0开始。我们可以通过下标访问数组中的元素。
数组赋值时没填满的部分会自动填0。
###  21. <a name='fontcolorpinkfont-1'></a><font color = pink>一维数组的名称</font>
统计整个数组在内存中的长度
```cpp
sizeof(arr)
```
可以获取数组在内存中的首地址
```cpp
int* p = &arr[1];
```
###  22. <a name='fontcolorpinkfont-1'></a><font color = pink>冒泡排序</font>
```cpp
#include <iostream>
using namespace std;
int main()
{
    //冒泡排序
    int line[] = {6,8,1,5,4,9,7,2,9};
    for(int i = 0;i < 9-1;i++)
    {
        for(int j = 0;j < 8-i;j++)
        {
            int t;
            if(line[j]>line[j+1])
            {
                t = line[j+1];
                line[j+1] = line[j];
                line[j] = t;
            }
        }
    }
    for(int i = 0;i < 9;i++)
    {
        cout<< line[i] <<" ";
    }
    cout << endl;
    return 0;
}
```
###  23. <a name='fontcolorpinkfont-1'></a><font color = pink>二维数组定义</font>
```cpp
int arr[row][col];
int arr[row][col] = {{v,v},{v,v}};
int arr[row][col] = {v,v,v,v};
int arr[][col] = {v,v,v,v};
```
###  24. <a name='fontcolorpinkfont-1'></a><font color = pink>二维数组的名称</font>
统计整个内存大小
```
1、查看整个矩阵的内存
2、查看某行的大小
3、查看某元素的大小
```
首地址
```
1、数组名称是首地址指针
```
###  25. <a name='fontcolorpinkfont-1'></a><font color = pink>字符串数组</font>
```cpp
string[] = {"张三","李四"};
```
###  26. <a name='fontcolorpinkfont-1'></a><font color = pink>函数</font>
作用：
1、将经常使用的代码封装起来，减少重复代码。
2、对于较大程序，一般分为若干程序块，每个模块实现特定功能。
###  27. <a name='fontcolorpinkfont-1'></a><font color = pink>函数的定义</font>
```
1、返回值类型	2、函数名	3、参数列表（形参列表）	4、函数体语句	5、return表达式
```
###  28. <a name='fontcolorpinkfont-1'></a><font color = pink>函数的调用</font>
语法：
```cpp
函数名(参数)
```
1、实际参数（实参）
2、形式参数（形参）
###  29. <a name='fontcolorpinkfont-1'></a><font color = pink>值传递</font>
1、所谓值传递，就是函数调用时，实参将参数值传给形式参数
2、值传递时候，如果形参变化，不会影响实参（函数体内对形参的任何操作都不会影响到外部的实参，例如交换函数，不会影响实参）
###  30. <a name='fontcolorpinkfont-1'></a><font color = pink>函数的常见样式</font>
无参无返 有参无返 无参有返 有参有返
###  31. <a name='fontcolorpinkfont-1'></a><font color = pink>函数的声明</font>
1、声明可以多次，定义只能一次。
2、可以提前告诉编译器函数的存在。
###  32. <a name='fontcolorpinkfont-1'></a><font color = pink>函数的分文件编写</font>
1、创建后缀名为.h的头文件
2、创建后缀名为.cpp的源文件
3、在头文件中写声明
4、在源文件中写定义
###  33. <a name='fontcolorpinkfont-1'></a><font color = pink>指针</font>
通过指针间接访问内存。指针变量保存的是另外一个变量的地址。
定义
```cpp
int* p = nullptr;
```
& 取地址符  * 取内容符
###  34. <a name='fontcolorpinkfont-1'></a><font color = pink>指针所占用的内存空间</font>
指针（无论什么类型int*，double*，float*），在32位系统（x86）中占用4字节。在64位系统（x64）中占用8字节。
###  35. <a name='fontcolorpinkfont-1'></a><font color = pink>空指针</font>
指向内存编号为0的空间
用途：初始化指针变量
注意：空指针的内存是不可以访问的,0~255之间的内存编号是系统使用的故不可以访问。
```cpp
int*p = NULL;
```
###  36. <a name='fontcolorpinkfont-1'></a><font color = pink>野指针</font>
指向非法的内存空间，空指针和野指针都不是我们自己申请的空间都不要随意去访问。
###  37. <a name='fontcolorpinkconstfont'></a><font color = pink>const修饰指针</font>
1、常量指针
* 指针的指向可以修改，但指针指向的内容不可以修改
```cpp
const int*p = &a;
```
2、指针常量
* 指针的指向不可以改，指针指向的值可以改。
```cpp
int* const p = &a;
```
3、双const
* 指针的指向不可以改，指针指向的值也不可以改。
```cpp
const int* const p = &a;
```
###  38. <a name='fontcolorpinkfont-1'></a><font color = pink>指针和数组</font>
```cpp
int*p = arr;	//arr就是数组首地址
p++ 就是下一个元素的地址
```
###  39. <a name='fontcolorpinkfont-1'></a><font color = pink>指针和函数</font>
1、值传递
2、地址传递
* 不想修改实参就用值传递，想修改实参就用地址传递
###  40. <a name='fontcolorpinkfont-1'></a><font color = pink>结构</font>
用户自定义数据类型
```cpp
struct st
{
    string name;
    int age;
};
```
定义
```cpp
//创建自定义变量 
st s1;
st s1 = {...};
```
定义结构体时，顺便创建一个结构体变量；
```cpp
struct st
{
    string name;
    int age;
}s1;
```
.成员运算符
```cpp
s1.name
```
###  41. <a name='fontcolorpinkfont-1'></a><font color = pink>结构体数组</font>
###  42. <a name='fontcolorpinkfont-1'></a><font color = pink>结构体指针</font>
1、创建自定义结构变量
2、通过指针指向结构体变量
3、通过指针访问结构体变量的数据
###  43. <a name='fontcolorpinkfont-1'></a><font color = pink>嵌套结构体</font>
结构体中的成员也是一个结构体
###  44. <a name='fontcolorpinkfont-1'></a><font color = pink>结构体作函数参数</font>
1、值传递
2、地址传递（效率更高）
###  45. <a name='fontcolorpinkconstfont-1'></a><font color = pink>结构体与const</font>
const是限定只读状态。
###  46. <a name='fontcolorpinkfont-1'></a><font color = pink>指针拷贝结构体</font>
指针可以少一分拷贝，节约内存（大大的节约，复制一个结构相当费内存）。
# <font color = skyblue>CPP核心编程</font>
###  47. <a name='fontcolorpinkfont-1'></a><font color = pink>内存四区</font>
意义：赋予不同的生命周期，提高编程灵活性。
```
1、代码区：存放函数体的二进制代码，由操作系统管理的
2、全局区；存放全局变量和静态变量以及常量
3、栈区：由编译器自动分配释放，存放函数的参数值，局部变量等
4、堆区：由程序员分配和释放，若程序员不释放，程序结束的时候由操作系统回收
```
* 程序运行前就有的：
代码区：
存放CPU执行的机器指令。
共享性，对于多次频繁被执行的程序，只需要在内存中有一份即可。
只读性，防止程序意外修改了它的指令。
全局区：
全局变量（global）、静态变量（static）、常量	1）字符串常量	2）const修饰的变量	(a) const修饰的全局变量	(b) const修饰的局部变量。该区域的数据在程序结束后由操作系统释放。
* 程序运行后才有的：
栈区 stack
堆区 heap
###  48. <a name='fontcolorpinkfont-1'></a><font color = pink>动态内存申请与释放</font>
new delete
###  49. <a name='fontcolorpinkfont-1'></a><font color = pink>引用</font>
给内存重新取一个名字
```cpp
数据类型 &别名 = 原名;
```
1、必须要初始化
2、初始化后不可以更改
###  50. <a name='fontcolorpinkfont-1'></a><font color = pink>值传递	地址传递	引用传递</font>

引用作为函数的返回值
1、不要返回局部变量的引用
2、函数的调用可以作为左值
```cpp
int& out()
{
    static int a = 10;  // 不要返回局部变量的引用
    return a;
}
	int& s = out();     //函数的调用可以作为左值
    out() = 100;
    cout<< s <<endl;
```
引用本质是一个指针常量（引用：自动挡；指针：手动挡）
```cpp
int& ref = a;
等价于
int* const ref = &a;
```
常量引用
```cpp
const int& ref = 10;
```
###  51. <a name='fontcolorpinkfont-1'></a><font color = pink>函数提高</font>
1、函数的默认参数
2、函数的占位参数

3、函数重载
* 函数名可以相同，提高复用性，同一作用域下，函数名称相同，函数参数类型不同，或者个数不同，或者顺序不同，都可以作为函数重载的标志。
<!--2025.1.9 jz hpc-->
###  52. <a name='fontcolorpinkfont-1'></a><font color = pink>类和对象（封装继承多态）</font>
CPP认为万物皆为对象，对象上有其属性和行为。
###  53. <a name='fontcolorpinkfont-1'></a><font color = pink>封装</font>
1、将属性和行为作为一个整体，表现生活中的事物。2、将属性和行为加以权限控制。
封装意义：在设计类的时候，属性和行为写在一起，表现事物。

封装语法：
```cpp
class 类名
{
访问权限:
    属性;
    行为;
};
```
实例化：通过一个类创建一个对象的过程。类：例如人类，是一种抽象出来的概念；对象：是具体化后的一个人，有特有的名字，年龄等。
类中的属性和行为，统一称为成员。属性，又名：成员属性、成员变量。行为，又名：成员函数、成员方法。
###  54. <a name='fontcolorpinkpublicprotectedprivatefont'></a><font color = pink>访问权限（public、protected、private）</font>
1、公共权限 public 成员，类内外皆可访问。2、保护权限 protected 成员，类内可以访问，类外不可访问。3、私有权限 private 成员，类内可以访问，类外不可访问。
保护和私有权限的区别在于继承，保护权限成员可以被子类继承，私有权限无法被继承。例如父亲的银行卡密码不想被儿子继承，那就银行卡密码设置为私有属性即可。
###  55. <a name='fontcolorpinkstructclassfont'></a><font color = pink>struct 和 class</font>
结构的默认权限是公有，类的默认权限是私有；其余没有区别。
###  56. <a name='fontcolorpinkfont-1'></a><font color = pink>私有化成员属性（通过预留的公有接口访问）</font>
优点：1、将所有成员属性设为私有，可以自己控制读写权限。2、对于写权限，可以检查数据的有效性。
###  57. <a name='fontcolorpinkfont-1'></a><font color = pink>对象的初始化和清理（构造与析构）</font>
构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。
析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。

构造与析构是非常重要的安全问题；不初始化，对其使用后果未知；不清理，可能造成内存泄漏等问题。如果我们不提供构造与析构函数，编译器会自己提供两个空实现作为构造析构函数。

语法：
```cpp
/*构造函数*/
类名(){}// 1、没有返回值，也不写void 2、函数名与类名相同 3、可以有参数，允许重载 4、程序生成对象时自动调用构造，无须手动调用，且只会调用一次。

/*析构函数*/
~类名(){}// 1、没有返回值，也不写void 2、函数名是波浪加类名 3、不可有参数，不许重载 4、程序在对象销毁前自动调用析构，无须手动调用，且只会调用一次。
```
###  58. <a name='fontcolorpinkfont-1'></a><font color = pink>构造函数的分类及调用</font>
按参数分：无参构造、有参构造。按类型分：普通构造、拷贝构造。
```cpp
/*无参构造*/
类名(){}
/*有参构造*/
类名(int a){}
/*拷贝构造*/
类名(const 类名& c) // 将传入对象的所有属性复制到新对象（克隆人）
```
调用：1、括号法  
```cpp
类名 c1;
类名 c2(10);
类名 c3(c2);
error：类名 f();    // 这个东西会被编译器误认为函数声明
```
2、显式法
```cpp
类名 c1;
类名 c2 = 类名(10); // 右侧为匿名对象，当前行执行结束后，匿名对象立即销毁
类名 c3 = 类名(c2);
error：类名(c3)     // 不要用拷贝构造函数初始化匿名对象。会重定义错误，命名重复。
```
3、隐式转换法
```cpp
类名 c1 = 10;       // 等价于：类名 c1 = 类名(10);
类名 c2 = c1;       // 等价于：类名 c2 = 类名(c1);
```
###  59. <a name='fontcolorpinkfont-1'></a><font color = pink>拷贝构造调用时机（什么时候用到拷贝构造）</font>
1、使用一个已经创建完毕的对象来初始化一个新对象。
```cpp
person p1(20);  // 调用有参构造
person p2(p1);  // 调用拷贝构造
```
2、值传递的方式给函数参数传值。
```cpp
void doWork(person p){}
void main()
{
    person p;   // 调用无参
    doWork(p);  // 调用拷贝
}
```
3、以值的方式返回局部对象。
```cpp
person doWork()
{
    person p1;
    return p1;
}
void main()
{
    person p = doWork();    // 调用拷贝
}
```
* 可以输出对象的地址，用来确定两个对象是否是同一个对象。
###  60. <a name='fontcolorpinkfont-1'></a><font color = pink>构造函数的调用规则</font>
* 默认情况下，编译器会给一个类添加三个函数：1、构造（空） 2、析构（空） 3、拷贝（对属性值拷贝）。
* 如果我们写了有参构造，编译器则不会补充默认构造，依然提供拷贝构造。
* 如果我们写了拷贝构造，编译器则不会补充其他普通构造。
###  61. <a name='fontcolorpinkfont-1'></a><font color = pink>浅拷贝与深拷贝</font>
* 浅拷贝：编译器提供的简单的赋值拷贝操作。
* 深拷贝：在堆区重新申请空间，进行拷贝操作。
```cpp
class person{
public:
    person(int age, int height){
        this->age = age;
        this->height = height;
    }
    ~person(){
        if(height != nullptr){
            delete height;
            height = nullptr;//置空，规避野指针
        }
    }
    int age;
    int* height;
};
```
* 浅拷贝只是单纯的把地址复制了过来，并没有申请新的堆内存。
* 总结：如果有在堆区开辟的属性，一定要自己提供拷贝构造，防止浅拷贝带来的问题。
###  62. <a name='fontcolorpinkfont-1'></a><font color = pink>对象初始化：初始化列表</font>
* 构造函数的任务是初始化，我们也可以用初始化列表的方式初始化。语法：
```cpp
person():m_a(10), m_b(10), m_c(10){}//写死了
person(int a, int b, int c):m_a(a), m_b(b), m_c(c){}//可变了
```
###  63. <a name='fontcolorpinkfont-1'></a><font color = pink>类对象作为类成员</font>
* 当其他类对象作为本类成员，构造时候先构造类对象，再构造自身。析构的顺序与构造相反。
```cpp
class A{};
class B{
    A a;
};
```
###  64. <a name='fontcolorpinkfont-1'></a><font color = pink>静态成员</font>
* 静态成员就是在成员变量和成员函数前加上关键字 static ，称为静态成员。
* 静态成员分为：1、静态成员变量 2、静态成员函数。
>静态成员变量
>>* 所有对象共享一份数据
>>* 在编译阶段分配内存（全局区）
>>* 类内声明，类外初始化

>静态成员函数
>>* 所有对象共享同一个函数（可以用类名直接访问）
>>* 静态成员函数只能访问静态成员变量
###  65. <a name='fontcolorpinkCfont-1'></a><font color = pink>C++对象模型（成员变量和成员函数分开存储）</font>
在cpp中，类内的成员变量和成员函数分开存储，只有非静态成员变量才属于类的对象。
```cpp
class person{};//空类
person p;//空对象
cout << "size of p" << sizeof(p) << endl;//答案：1字节
```
* 编译器为空对象分配的一个字节，是为了区分空对象占用内存的位置，每个空对象也应该有一个独一无二的内存地址。
```cpp
class person{
    int a;
};//空类
person p;//空对象
cout << "size of p" << sizeof(p) << endl;//答案：4字节
```
>* 非静态成员变量，在类的对象上
>* 静态成员变量，不在类的对象上
>* 非静态成员函数，不在类的对象上
>* 静态成员函数，不在类的对象上
###  66. <a name='fontcolorpinkthisfont'></a><font color = pink>this 指针</font>
* this 指针是隐含在每一个非静态成员函数内的一种指针
* this指针不需要定义，直接使用即可

this 指针的用途

* 当形参和成员变量同名的时，可用 this 指针区分，`this指针指向的是被调用的成员函数所属的函数`。
* 在类的非静态成员函数中返回对象本身，可使用 return *this
```cpp
//我晕了，不一定对
class person{
public:
    int age;
    person(int age){
        this->age = age;
    }
    
    person& addage(){
        this->age += p.age;
        return* this;
    }
};
void main()
{
    p2.addage(p1).addage(p1).addage(p1).addage(p1);//链式编程思想
}
```
###  67. <a name='fontcolorpinkfont-1'></a><font color = pink>空指针访问成员函数</font>
###  68. <a name='fontcolorpinkconstfont-1'></a><font color = pink>const 修饰成员函数</font>
mutable 可以改常函数
# 2025.1.15
###  69. <a name='fontcolorpinkfont-1'></a><font color = pink>友元</font>
* 生活中你家中有客厅（public），有你的卧室（private）。客厅所有来的客人都可以进去，但是你的卧室是私有的，一般只有你能进去，你也可以允许你的好朋友进入。
* 在程序里，有些私有属性也想让类外特殊的一些函数或者类进行访问，就需要用到友元技术。友元的目的就是让一个函数或者类，访问另外一个类的私有成员。
* 友元的关键字为 friend 。
```
友元的三种实现：
1、全局函数做友元
2、类做友元
3、成员函数做友元
```
1、全局函数做友元，例程：
```cpp
#include <string>
#include <iostream>

class house
{
	friend void goodman(house& hou);//写最上边就好，对权限没有要求
public:
	house();
	~house();
	std::string sittingroom;
private:
	std::string bedroom;
};

house::house()
{
	sittingroom = "客厅";
	bedroom = "卧室";
}

house::~house()
{
}

void goodman(house& hou)//引用传递
{
	std::cout << "goodman正在访问：" << hou.bedroom << std::endl;
}

void goodwoman(house* hou)//指针传递
{
	std::cout << "goodwoman正在访问：" << hou->sittingroom << std::endl;
}

void goodchild(house hou)//值传递
{
	std::cout << "goodchild正在访问：" << hou.sittingroom << std::endl;
}

int main()
{
	house ho;
	goodman(ho);
	goodwoman(&ho);
	goodchild(ho);
	system("pause");
	return 0;
}
```
2、类做友元，例程：
```cpp
#include <string>
#include <iostream>

class house
{
	friend class goodGay;
public:
	house()
	{
		sittingroom = "客厅";
		bedroom = "卧室";
	}
	~house() {};
	std::string sittingroom;
private:
	std::string bedroom;
};

class goodGay
{
public:
	goodGay()
	{
		building = new house;
	}
	~goodGay()
	{
		delete building;
	}
	house* building;
	void visit()
	{
		std::cout << "好基友正在访问：" << building->sittingroom << std::endl;
		std::cout << "好基友正在访问：" << building->bedroom << std::endl;//友元在类内才能访问私有属性
	}
};

int main()
{
	goodGay Mike;
	Mike.visit();
	std::cout << "好基友正在访问：" << Mike.building->sittingroom << std::endl;
	std::cout << "好基友正在访问：" << Mike.building->sittingroom << std::endl;//类外即便是友元也无法调用私有属性
	system("pause");
	return 0;
}
```
3、成员函数做友元，例程：
```cpp
报错！详情见question
```
###  70. <a name='fontcolorpinkfont-1'></a><font color = pink>运算符重载</font>
* 运算符重载的概念：对已有的运算符重新进行定义，赋予其另外一种功能，以适应不同的数据类型（自定义类）。
```
1、加号运算符重载。
2、左移运算符重载。
3、递增运算符重载。
4、赋值运算符重载。
5、关系运算符重载。
6、函数调用运算符重载。
```
* 1、加号运算符重载。(通过成员函数重载加号)
```cpp
#include <iostream>

class person
{
public:
	person(int a = 0, int b = 0)
	{
		this->a = a;
		this->b = b;
	}
	int a;
	int b;
	person operator+ (person& p)
	{
		person tmp;
		tmp.a = this->a + p.a;
		tmp.b = this->b + p.b;
		return tmp;
	}
};

int main()
{
	person p1(3, 5);
	person p2(4, 6);
	person p3 = p1 + p2;
	std::cout << p3.a << " " << p3.b << std::endl;
	system("pause");
	return 0;
}
```
通过全局函数重载
```cpp
person operator+ (person& p1, person& p2)
{
	person tmp;
	tmp.a = p1.a + p2.a;
	tmp.b = p1.b + p2.b;
	return tmp;
}
```
# 2025.1.17
* 2、左移运算符重载
通过全局函数配合友元实现重载，也可以用成员函数重载(但不好用)。
```cpp
#include <iostream>
using namespace std;
class person
{
	friend ostream& operator<< (ostream& cout, person& p);
public:
	person(int, int);
	~person();
private:
	int a;
	int b;
};
person::person(int a, int b)
{
	this->a = a;
	this->b = b;
}
person::~person(){}
ostream& operator<< (ostream& cout, person& p)
{
	cout << p.a << " " << p.b << endl;
	return cout;
}
int main()
{
	person p(5, 3);
	cout << p << endl << p << "hello" << endl;
	return 0;
}
```
* 3、递增运算符重载

> * * * *  ** * *** ****   * >>>>>> 其他重载略
###  71. <a name='fontcolorpinkfont-1'></a><font color = pink>继承</font>
* 继承的好处：减少重复的代码
```
语法：class 子类：继承方式 父类

子类：派生类
父类：基类
```
###  72. <a name='fontcolorpinkfont-1'></a><font color = pink>开发人员命令提示查看对象模型</font>
###  73. <a name='fontcolorpinkfont-1'></a><font color = pink>多继承</font>
###  74. <a name='fontcolorpinkvirtualfont'></a><font color = pink>virtual 虚继承</font>
###  75. <a name='fontcolorpinkfont-1'></a><font color = pink>文件流</font>
* 虚基类
# <font color = skyblue>CPP提高编程（模板与泛型编程）</font>
###  76. <a name='fontcolorpinkfont-1'></a><font color = pink>模板</font>
###  77. <a name='fontcolorpinkSTL-standardtemplatelibraryfont'></a><font color = pink>STL - standard template library（标准模板库）</font>
STL 分类
```
1、容器
2、算法
3、迭代器
```
STL 六大组件
```
1、容器 vector list deque set map
2、算法 sort find copy for_each
3、迭代器
4、仿函数
5、适配器（配接器）
6、空间配置器
```
